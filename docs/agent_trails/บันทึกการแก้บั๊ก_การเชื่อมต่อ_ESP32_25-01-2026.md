# บันทึกการทำงาน (Agent Trails): การแก้บั๊กการเชื่อมต่อ ESP32 Micro-ROS

**วันที่:** 25-01-2026
**งาน:** แก้ไขปัญหาการเชื่อมต่อ Micro-ROS ของ ESP32 (มอเตอร์ไม่ทำงาน)
**สถานะ:** ✅ แก้ไขเรียบร้อย

## 1. บริบทและบทวิเคราะห์ปัญหา
**ปัญหา:** ผู้ใช้แจ้งว่ามอเตอร์ไม่ทำงานหลังจากกด "Start System" แผนที่ทำงานปกติ (LiDAR ทำงาน) แต่ ESP32 ไม่เชื่อมต่อกับ Micro-ROS Agent
**สิ่งที่สังเกตเห็นเบื้องต้น:** 
- Process `micro_ros_agent` หายไปหรือดับทันทีหลังเริ่มรัน
- ไฟ LED บน ESP32 แสดงผลไม่ปกติ (บางครั้งดับ บางครั้งกะพริบ)
- Log แสดงข้อผิดพลาด `user interrupted with ctrl-c` (SIGINT) และก่อนหน้านั้นมี `exit code -2`

## 2. บันทึกการตัดสินใจและการดำเนินการ

### การตัดสินใจที่ 1: ตรวจสอบ "Exit Code -2" ของ Micro-ROS Agent
- **สิ่งที่พบ:** คำสั่ง `ps aux` แสดงให้เห็นว่ามี process `robot_system.launch.py` รันซ้ำซ้อนกัน (PID 7204, 9752)
- **การวิเคราะห์:** เกิด Race condition ในการแย่งใช้พอร์ต `/dev/ttyACM0` โดย process ใหม่พยายามรันในขณะที่ process เก่ายังถือครองพอร์ตอยู่
- **การดำเนินการ:** 
  - ทำการ Kill zombie process ทั้งหมดแบบ Manual
  - แก้ไขไฟล์ `start_robot.sh` โดยเพิ่มคำสั่ง `pkill -f "robot_system.launch.py"` ก่อนเริ่มรันระบบใหม่
- **ผลลัพธ์:** Agent เริ่มทำงานได้ แต่ไฟล์ Agent ดับลงอีกครั้งเนื่องจาก "Device busy"

### การตัดสินใจที่ 2: ระบุตัวที่ล็อคพอร์ต
- **สิ่งที่พบ:** คำสั่ง `lsof /dev/ttyACM0` พบว่า process `java` (Arduino IDE) กำลังถือครองพอร์ตอยู่
- **การวิเคราะห์:** ผู้ใช้น่าจะทำการอัปโหลดโค้ดแล้วเปิด Serial Monitor หรือ IDE ทิ้งไว้
- **การดำเนินการ:** Kill process `12036` (Arduino IDE)
- **ผลลัพธ์:** คืนค่าพอร์ตว่าง Agent สามารถเริ่มทำงานได้สำเร็จ (PID 25871)

### การตัดสินใจที่ 3: ตรวจสอบ Logics ของฮาร์ดแวร์ (ESP32)
- **สิ่งที่พบ:** แม้ Agent จะรันอยู่ แต่ ESP32 ก็ยังไม่เชื่อมต่อ (ไม่มี Log `create_client` ปรากฏ)
- **สมมติฐาน:** ESP32 อาจอยู่ในสถานะค้าง หรือลำดับเวลา (Timing) ของการเริ่ม Agent และการ Boot ของ ESP32 ไม่ตรงกัน
- **การดำเนินการ:** 
  - อัปเดตไฟล์ `base_control.ino` เพื่อเพิ่ม **LED Diagnostic**:
    - **กะพริบ:** `WAITING_AGENT` (กำลังรอการเชื่อมต่อ)
    - **สว่างค้าง:** `AGENT_CONNECTED` (เชื่อมต่อสำเร็จ)
  - แนะนำให้ผู้ใช้ทำการ **RESET** ESP32 ด้วยปุ่มกดในขณะที่ Agent กำลังรันอยู่
- **ผลลัพธ์:** หลังจาก Reset ไฟ LED สว่างค้าง และการเชื่อมต่อถูกสร้างขึ้นสำเร็จ

### การตัดสินใจที่ 4: ยกเลิกการใช้สคริปต์ Auto-Reset
- **สิ่งที่พบ:** สคริปต์ `esp32_reset.py` ที่คอยสลับสัญญาณ DTR ทำให้ ESP32 เข้าสู่ **Bootloader Mode** (ไฟ LED ดับ) แทนที่จะเป็นการ Reset ปกติ ทำให้การเชื่อมต่อหลุดถาวรจนกว่าจะถอดปลั๊กเสียบใหม่
- **การดำเนินการ:** ปิดการใช้งาน `esp32_reset.py` ทั้งใน `start_robot.sh` และ `robot_system.launch.py`
- **ผลลัพธ์:** ระบบเปลี่ยนมาใช้กลไกที่ `micro_ros_agent` รอรับ Ping จาก ESP32 แทน ผู้ใช้ยืนยันว่าการเชื่อมต่อกลับมาเองโดยอัตโนมัติหลังจากรอสักครู่ (~10-20 วินาที) โดยไม่ต้องทำอะไรเพิ่ม

### การตัดสินใจที่ 5: ปรับจูนพารามิเตอร์การเชื่อมต่อ
- **สิ่งที่พบ:** ค่าเริ่มต้นของ Ping interval (500ms) ทำให้การเชื่อมต่อใหม่ล่าช้า (สูงสุด 27 วินาที)
- **การดำเนินการ:** ปรับแต่งค่า `rmw_uros_ping_agent` interval
- **ค่าที่เลือก:** ผู้ใช้เลือกที่ **200ms** (สมดุล) แทนที่จะเป็น 100ms (เร็วมากแต่กินทรัพยากร) หรือ 500ms (ช้าเกินไป) และตั้งค่าความเร็วกะพริบของ LED ไว้ที่ **150ms**
- **ผลลัพธ์:** ประสบการณ์การเริ่มระบบดีขึ้นในขณะที่ยังรักษาความเสถียรของระบบไว้ได้

## 3. การเปลี่ยนแปลงการตั้งค่า
### ไฟล์: `Back-end/scripts/start_robot.sh`
- เพิ่มการล้างข้อมูล (Cleanup) ของ `robot_system.launch.py` เพื่อป้องกัน instance ที่ซ้ำซ้อน

### ไฟล์: `hardware/arduino/base_control/base_control.ino`
- ปรับปรุง Logic การแสดงผล LED เพื่อให้ง่ายต่อการ Debug

## 4. บทเรียนที่ได้รับ
- **ตรวจสอบ zombie launch processes เสมอ** เมื่อต้องจัดการกับ Hardware interface ของ ROS 2
- **การแย่งชิงพอร์ตกับ IDE** เป็นปัญหาที่พบได้บ่อยในการพัฒนา Firmware ไมโครคอนโทรลเลอร์ควบคู่ไปกับ ROS drivers
- **ลำดับเวลาในการ Reset ฮาร์ดแวร์มีความสำคัญ:** Micro-ROS มักต้องการให้ Agent พร้อมทำงาน *ก่อนที่* Client จะเริ่ม หรือต้องมีการ Reset แบบ Manual เพื่อเริ่มขั้นตอน Handshake ใหม่
